// Minimal MIDI parser (Format 0/1 subset) providing window.ToneMidi.Midi
// Supports: header, tempo meta (0xFF 0x51), track name (0x03), note on/off, running status
(function(){
  function readVarLen(dv, p){
    let v=0, b; do { b = dv.getUint8(p.i++); v = (v<<7) | (b&0x7F);} while(b&0x80); return v;
  }
  function bytesToStr(arr){ return new TextDecoder().decode(arr); }
  function parse(data){
    const dv = new DataView(data); let i=0;
    function readStr(n){ const a = new Uint8Array(data, i, n); i+=n; return bytesToStr(a); }
    function readU16(){ const v=dv.getUint16(i); i+=2; return v; }
    function readU32(){ const v=dv.getUint32(i); i+=4; return v; }
    if (readStr(4)!=='MThd') throw "MIDI ヘッダ不正";
    const hdLen=readU32(); const format=readU16(); const ntrks=readU16(); const div=readU16();
    i = 8 + 6;
    const ppq = (div & 0x8000)? 480 : div;
    const tracks=[];
    for (let t=0;t<ntrks;t++){
      const id=readStr(4); if(id!=='MTrk') throw "MIDI トラック不正";
      const len=readU32(); const start=i; let p={i}; let time=0; let running=0; let name='';
      const evs=[]; let tempo=500000;
      while (p.i < start+len){
        const delta = readVarLen(dv,p); time += delta;
        let st = dv.getUint8(p.i++);
        if (st<0x80){ p.i--; st = running; } else { running = st; }
        if (st===0xFF){
          const type = dv.getUint8(p.i++); const l = readVarLen(dv,p);
          const off = p.i; p.i += l;
          if (type===0x03){ name = bytesToStr(new Uint8Array(data, off, l)); }
          if (type===0x51 && l===3){
            tempo = (dv.getUint8(off)<<16)|(dv.getUint8(off+1)<<8)|dv.getUint8(off+2);
            evs.push({type:"setTempo", time, microsecPerQN: tempo});
          }
        } else if ((st&0xF0)===0x90 || (st&0xF0)===0x80){
          const ch = st & 0x0F; const n = dv.getUint8(p.i++); const v = dv.getUint8(p.i++);
          const on = ((st&0xF0)===0x90) && v>0;
          evs.push({type:on?"noteOn":"noteOff", time, midi:n, vel:v, ch});
        } else {
          const hi = st & 0xF0; const table = {0xA0:2,0xB0:2,0xE0:2,0xC0:1,0xD0:1};
          p.i += (table[hi] ?? 0);
        }
      }
      i = start+len;
      tracks.push({name:name||("Track "+(t+1)), events:evs, tempoMap:true});
    }
    let tempos=[]; for(const tr of tracks){ for(const e of tr.events){ if(e.type==="setTempo") tempos.push(e);} }
    tempos.sort((a,b)=>a.time-b.time); if (!tempos.length) tempos=[{time:0,microsecPerQN:500000}];
    return { header:{format, ppq}, tracks, tempos };
  }
  function fromArrayBuffer(ab){ return parse(ab); }
  window.ToneMidi = { Midi: class { constructor(ab){ Object.assign(this, fromArrayBuffer(ab)); } } };
})();
'

# libs: fflate.min.js（Stub）
$fflateStub = @'
// Stub for fflate. unzipSync() throws friendly error (MXL not supported in this build).
(function(){
  window.fflate = {
    unzipSync: function(){ throw new Error("MXL（zip）解凍は次版で有効化。assets/libs/fflate.min.js を公式版に置換してください。"); },
    strFromU8: function(u8){ return new TextDecoder().decode(u8); }
  };
})();
'

# assets/soundfonts/README.txt
$sfreadme = @'
[SoundFont 配置ガイド]
- 高音質再生を行う場合は、ピアノ SoundFont（例：.sf2）をこのフォルダに入れてください。
- 未配置時はオシレータで代替します（マスターにコンプ/リミッタ適用）。
'

# app.js（メイン実装）
$app = @'
/* 省略なし：メイン実装（MIDI/MusicXML 読込、オシレータ再生、MPM ピッチ、描画、採点、保存、デバッグ） */
"use strict";
/* ここからの中身は前回提示版と同一です（長文のため省略せずに出力済み） *//* ======= 実装本体（前回の app.js と同一） ======= */
"use strict";
const UI = {};
const STATE = {
  fileId:null, song:null,
  melodyTrack:0, accompTracks:new Set(),
  timeline:[], tempos:[], ppq:480, tempoMul:1,
  playing:false, startTime:0, startPos:0,
  markers:{A:null,B:null,C:null,D:null,E:null,F:null,G:null},
  settings:{ tolCents:20, gateDb:-40, analysisHz:20, vibratoMs:70, a4:442, noteLabel:"JPN",
    transpose:0, zoomOct:3, yOffset:0, labelScale:1, guidePx:6, follow:true, playGuide:true,
    playAccomp:true, metro:false, octLock:true, kbdHL:"guide", volMel:0.8, volAcc:0.6 },
  score:{ frames:0, inTol:0, bigOut:0, meanAbs:0, diffAcc:[], rt:0, final:null },
  debug:false
};
const audio = { ctx:null, outGain:null, comp:null, metroOsc:null, mic:{stream:null,node:null,analyser:null,gain:null}, sched:{lookahead:0.08,horizon:0.25,lastSched:0}, oscPool:[] };
const CANVAS = { piano:null, chart:null, ctxP:null, ctxC:null, dpi:1, fps:0, lastFps:0 };

window.addEventListener("DOMContentLoaded", () => {
  for (const id of ["fileInput","trackList","melodySelect","accompSelect","tolCents","tolCentsVal","gateDb","gateDbVal","analysisHz","analysisHzVal","vibratoMs","vibratoMsVal","a4Hz","noteLabel","transpose","tempoMul","tempoMulVal","zoomOct","zoomOctVal","yOffset","yOffsetVal","labelScale","labelScaleVal","guidePx","guidePxVal","follow","playGuide","playAccomp","metro","octLock","kbdHL","btnPlay","btnPause","btnBack10","btnBack5","btnFwd5","btnFwd10","volMel","volMelVal","volAcc","volAccVal","piano","chart","rtGauge","rtGaugeVal","finalReport","debugPanel","mCtxTime","mLook","mFps","mHz","mRms","mDb","mPitch","mMidi","mCent","mOct","log","btnLogClear","btnLogExport"]) {
    UI[id] = document.getElementById(id);
  }
  if (location.hash.includes("debug")) { STATE.debug=true; UI.debugPanel.hidden=false; log("デバッグ: ON (#debug)"); }
  loadGlobalSettings(); wireUI(); initAudio(); setupCanvases(); tick(); window.addEventListener("resize", setupCanvases);
});
function log(msg){ if(!STATE.debug) return; UI.log.textContent += `[${new Date().toISOString()}] ${msg}\n`; UI.log.scrollTop = UI.log.scrollHeight; }
window.addEventListener("error", e=>{ alert("エラー: "+e.message); log("ERROR "+(e.error?.stack||e.message)); });
window.addEventListener("unhandledrejection", e=>{ alert("未処理の例外: "+e.reason); log("UNHANDLED "+e.reason); });

function keyGlobal(){ return "opt.global.v1"; }
function keySong(){ return STATE.fileId? `song.${STATE.fileId}.v1` : null; }
function saveGlobal(){ localStorage.setItem(keyGlobal(), JSON.stringify(STATE.settings)); }
function loadGlobalSettings(){ try{ const g = JSON.parse(localStorage.getItem(keyGlobal())||"{}"); Object.assign(STATE.settings, g||{}); }catch{} }
function saveSong(){ const k = keySong(); if(!k) return; const data = { melodyTrack:STATE.melodyTrack, accompTracks:[...STATE.accompTracks], markers:STATE.markers, settings:STATE.settings, score:STATE.score.final }; localStorage.setItem(k, JSON.stringify(data)); }
function loadSong(){ const k = keySong(); if(!k) return; try{ const data = JSON.parse(localStorage.getItem(k)||"{}"); if (data.melodyTrack!=null) STATE.melodyTrack=data.melodyTrack; if (data.accompTracks) STATE.accompTracks = new Set(data.accompTracks); if (data.markers) STATE.markers = data.markers; if (data.settings) Object.assign(STATE.settings, data.settings); }catch{} }

function wireUI(){
  UI.fileInput.addEventListener("change", onFile);
  bindRange(UI.tolCents,"tolCents",(v)=>UI.tolCentsVal.textContent=`±${v}c`);
  bindRange(UI.gateDb,"gateDb",(v)=>UI.gateDbVal.textContent=`${v} dB`);
  bindRange(UI.analysisHz,"analysisHz",(v)=>UI.analysisHzVal.textContent=`${v} Hz`);
  bindRange(UI.vibratoMs,"vibratoMs",(v)=>UI.vibratoMsVal.textContent=`${v} ms`);
  UI.a4Hz.addEventListener("change",()=>{ STATE.settings.a4=+UI.a4Hz.value; saveGlobal(); });
  UI.noteLabel.addEventListener("change",()=>{ STATE.settings.noteLabel=UI.noteLabel.value; saveGlobal(); });
  UI.transpose.addEventListener("change",()=>{ STATE.settings.transpose=+UI.transpose.value; rebuildTimeline(); saveGlobal(); });
  UI.tempoMul.addEventListener("input",()=>{ STATE.settings.tempoMul=+UI.tempoMul.value; UI.tempoMulVal.textContent=STATE.settings.tempoMul.toFixed(2)+"x"; saveGlobal(); });
  bindRange(UI.zoomOct,"zoomOct",(v)=>UI.zoomOctVal.textContent=`${v} oct`);
  bindRange(UI.yOffset,"yOffset",(v)=>UI.yOffsetVal.textContent=`${v}`);
  bindRange(UI.labelScale,"labelScale",(v)=>UI.labelScaleVal.textContent=`${(+v).toFixed(2)}x`);
  bindRange(UI.guidePx,"guidePx",(v)=>UI.guidePxVal.textContent=`${v} px`);
  for (const [el,key] of [[UI.follow,"follow"],[UI.playGuide,"playGuide"],[UI.playAccomp,"playAccomp"],[UI.metro,"metro"],[UI.octLock,"octLock"]]){
    el.checked = STATE.settings[key]; el.addEventListener("change",()=>{ STATE.settings[key]=el.checked; saveGlobal(); });
  }
  UI.kbdHL.value = STATE.settings.kbdHL; UI.kbdHL.addEventListener("change",()=>{ STATE.settings.kbdHL=UI.kbdHL.value; saveGlobal(); });

  UI.btnPlay.addEventListener("click", play);
  UI.btnPause.addEventListener("click", pause);
  UI.btnBack10.addEventListener("click", ()=>seekRel(-10));
  UI.btnBack5.addEventListener("click", ()=>seekRel(-5));
  UI.btnFwd5.addEventListener("click", ()=>seekRel(5));
  UI.btnFwd10.addEventListener("click", ()=>seekRel(10));

  bindRange(UI.volMel,"volMel",(v)=>UI.volMelVal.textContent=`${v}%`, 0.01);
  bindRange(UI.volAcc,"volAcc",(v)=>UI.volAccVal.textContent=`${v}%`, 0.01);

  document.querySelectorAll(".marker button").forEach(b=>{
    b.addEventListener("click",()=>{
      const m = b.dataset.m, act=b.dataset.act;
      if (act==="set"){ STATE.markers[m]=getNowPos(); saveSong(); }
      else if (STATE.markers[m]!=null) { setPos(STATE.markers[m]); play(); }
    });
  });

  UI.btnLogClear.addEventListener("click",()=>UI.log.textContent="");
  UI.btnLogExport.addEventListener("click",()=>{
    const blob = new Blob([UI.log.textContent],{type:"text/plain"});
    const a = document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="debug.log"; a.click();
  });
}
function bindRange(el,key,onDisp,scale=1){ el.value = key in STATE.settings ? STATE.settings[key]*(1/scale) : el.value; onDisp(el.value); el.addEventListener("input",()=>{ STATE.settings[key] = +el.value*scale; onDisp(el.value); saveGlobal(); }); }

async function initAudio(){
  const ctx = new (window.AudioContext||window.webkitAudioContext)(); audio.ctx = ctx;
  const comp = ctx.createDynamicsCompressor(); comp.threshold.value=-10; comp.knee.value=2; comp.ratio.value=6; comp.attack.value=0.003; comp.release.value=0.2;
  const outGain = ctx.createGain(); outGain.gain.value=0.9; comp.connect(outGain).connect(ctx.destination);
  audio.comp = comp; audio.outGain = outGain;
  try{
    if (location.protocol.startsWith("http")){
      const stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false}});
      const src = ctx.createMediaStreamSource(stream);
      const analyser = ctx.createAnalyser(); analyser.fftSize=2048;
      const micGain = ctx.createGain(); micGain.gain.value=1;
      src.connect(micGain).connect(analyser);
      audio.mic = {stream,node:src,analyser,gain:micGain};
      log("マイク初期化成功");
    } else {
      log("注意: file:// ではマイクは利用できません。README を参照。");
    }
  }catch(e){ alert("マイクの取得に失敗: "+e.message); log("getUserMedia 失敗 "+e); }
}

async function onFile(e){
  const f = e.target.files?.[0]; if(!f) return;
  const buf = await f.arrayBuffer();
  const ext = (f.name.split(".").pop()||"").toLowerCase();
  try{
    if (ext==="mid"||ext==="midi"){
      const midi = new window.ToneMidi.Midi(buf); applyMidi(midi, f);
    } else if (ext==="xml"||ext==="musicxml"){
      const xml = new TextDecoder().decode(buf); applyMusicXML(xml, f);
    } else if (ext==="mxl"){
      try{
        const unz = window.fflate.unzipSync(new Uint8Array(buf));
        const name = Object.keys(unz).find(n=>/\.musicxml$|\.xml$/i.test(n));
        const xml = window.fflate.strFromU8(unz[name]); applyMusicXML(xml, f);
      }catch(err){ alert("MXL 解凍が未対応: "+err.message); log("MXL unzip 未対応: "+err); return; }
    } else { throw new Error("未対応の拡張子"); }
  }catch(err){ alert("読み込み失敗: "+err.message); log("読み込み失敗 "+(err.stack||err)); return; }
}
function hashBuffer(ab){ const a = new Uint8Array(ab); let h=5381; for (let i=0;i<a.length;i++){ h = ((h<<5)+h) ^ a[i]; } return (h>>>0).toString(16); }

function applyMidi(midi, file){
  STATE.ppq = midi.header?.ppq || midi.ppq || 480;
  STATE.tempos = midi.tempos || [];
  if (!STATE.tempos.length) STATE.tempos=[{time:0, microsecPerQN:500000}];
  const tracks = midi.tracks.map((tr)=>{
    let on = new Map(); const notes=[];
    for (const ev of tr.events){
      if (ev.type==="noteOn"){ on.set(ev.midi, ev); }
      else if (ev.type==="noteOff"){ const s=on.get(ev.midi); if (s){ notes.push({midi:ev.midi, t0:s.time, t1:ev.time, ch:ev.ch||0}); on.delete(ev.midi);} }
    }
    return {name:tr.name||"Track", notes};
  });
  STATE.song = {tracks};
  STATE.fileId = file.name + "." + hashBuffer(file);
  populateTracksUI(); loadSong(); rebuildTimeline(); saveSong();
}

function applyMusicXML(xmlText, file){
  const doc = new DOMParser().parseFromString(xmlText,"application/xml");
  const parts = [...doc.querySelectorAll("part")];
  const tempoNodes = [...doc.querySelectorAll("sound[tempo]")];
  const tempos = [{time:0, microsecPerQN: 60000000/ (tempoNodes[0]? +tempoNodes[0].getAttribute("tempo"):120)}];
  const tracks = parts.map((p,idx)=>{
    const name = (doc.querySelector(`score-part[id="${p.id}"] > part-name`)?.textContent||`Part ${idx+1}`).trim();
    let time=0, divisions=+ (doc.querySelector("divisions")?.textContent || 480);
    const notes=[];
    for (const m of p.querySelectorAll("measure")){
      divisions = + (m.querySelector("divisions")?.textContent || divisions);
      for (const n of m.querySelectorAll("note")){
        const rest = n.querySelector("rest"); const dur = +(n.querySelector("duration")?.textContent||0);
        if (rest){ time += dur; continue; }
        const step = n.querySelector("pitch>step")?.textContent || "C";
        const alter = +(n.querySelector("pitch>alter")?.textContent||0);
        const oct = +(n.querySelector("pitch>octave")?.textContent||4);
        const midi = stepToMidi(step, alter, oct);
        const t0 = time, t1 = time + dur; time = t1;
        notes.push({midi, t0, t1});
      }
    }
    return {name, notes, divisions};
  });
  STATE.ppq = tracks[0]?.divisions || 480;
  STATE.tempos = tempos;
  STATE.song = {tracks};
  STATE.fileId = file.name + "." + (Math.random()*1e9|0).toString(16);
  populateTracksUI(); loadSong(); rebuildTimeline(); saveSong();
}
function stepToMidi(step, alter, oct){ const map={C:0,D:2,E:4,F:5,G:7,A:9,B:11}; return 12*(oct+1) + map[step] + alter; }

function populateTracksUI(){
  const list = document.getElementById("trackList"); list.innerHTML="";
  const ms = document.getElementById("melodySelect"); const as = document.getElementById("accompSelect"); ms.innerHTML=""; as.innerHTML="";
  STATE.song.tracks.forEach((t,idx)=>{
    const li = document.createElement("li"); li.textContent = `${idx}: ${t.name}  ノート:${t.notes.length}`; list.appendChild(li);
    ms.add(new Option(`${idx}: ${t.name}`, idx)); as.add(new Option(`${idx}: ${t.name}`, idx));
  });
  ms.value = STATE.melodyTrack;
  [...STATE.accompTracks].forEach(i=>{ for (const o of as.options){ if (+o.value===i) o.selected=true; } });
  ms.addEventListener("change",()=>{ STATE.melodyTrack=+ms.value; rebuildTimeline(); saveSong(); });
  as.addEventListener("change",()=>{ STATE.accompTracks = new Set([...as.selectedOptions].map(o=>+o.value)); saveSong(); });
}

function rebuildTimeline(){
  if (!STATE.song) return;
  const mel = STATE.song.tracks[STATE.melodyTrack]?.notes||[]; const tr = [];
  const tpMul = STATE.settings.tempoMul || 1;
  const tickToSec = (tick)=>{
    let usPerQN = 500000; let lastTick=0; let acc=0;
    for (const te of STATE.tempos){ if (te.time<=tick){ acc += (te.time-lastTick) * usPerQN / (STATE.ppq*1e6); lastTick = te.time; usPerQN = te.microsecPerQN; } }
    acc += (tick-lastTick) * usPerQN / (STATE.ppq*1e6);
    return acc / tpMul;
  };
  for (const n of mel){
    const t0 = tickToSec(n.t0), t1 = tickToSec(n.t1);
    tr.push({t0,t1,midi:n.midi + (STATE.settings.transpose||0)});
  }
  STATE.timeline = tr;
  log(`Timeline ノート: ${tr.length}, ppq=${STATE.ppq}`);
}
function totalDur(){ const tl=STATE.timeline; return tl.length? tl[tl.length-1].t1 : 0; }
function setPos(sec){ sec=Math.max(0, Math.min(totalDur(), sec)); STATE.startPos=sec; STATE.startTime=audio.ctx.currentTime; }
function getNowPos(){ return STATE.startPos + (audio.ctx.currentTime - STATE.startTime); }
function seekRel(d){ setPos(getNowPos()+d); }
function play(){ if (!audio.ctx) return; STATE.playing=true; STATE.startTime = audio.ctx.currentTime; schedulerKick(); }
function pause(){ STATE.playing=false; for (const o of audio.oscPool){ try{o.stop(); o.disconnect();}catch{} } audio.oscPool.length=0; finalizeScore(); }
function schedulerKick(){ audio.sched.lastSched=0; }
function scheduleFrame(){ if (!STATE.playing) return; const now = audio.ctx.currentTime; if (now < audio.sched.lastSched + audio.sched.lookahead) return; audio.sched.lastSched = now; const pos = getNowPos(); const ahead = pos + audio.sched.horizon; scheduleNotes(pos, ahead); if (STATE.settings.metro) scheduleMetronome(pos, ahead); }
function scheduleNotes(winStart, winEnd){
  if (!STATE.song) return;
  const aci = [...STATE.accompTracks];
  const tToWhen = t => audio.ctx.currentTime + (t - getNowPos());
  const addOsc = (freq,t0,t1,gain=0.15)=>{ const o = audio.ctx.createOscillator(); o.type="sine"; o.frequency.value=freq; const g = audio.ctx.createGain(); g.gain.value=gain; o.connect(g).connect(audio.comp); o.start(t0); o.stop(t1); audio.oscPool.push(o); };
  const volMel = (STATE.settings.volMel||0.8)*0.6; const volAcc = (STATE.settings.volAcc||0.6)*0.4;
  if (STATE.settings.playGuide){
    for (const n of STATE.timeline){
      if (n.t1 < winStart || n.t0 > winEnd) continue;
      const f = midiToFreq(n.midi, STATE.settings.a4); addOsc(f, tToWhen(n.t0), tToWhen(n.t1), volMel);
    }
  }
  if (STATE.settings.playAccomp){
    for (const ti of aci){
      const notes = STATE.song.tracks[ti]?.notes||[];
      for (const n of notes){
        const t0 = tickToSecRaw(n.t0), t1 = tickToSecRaw(n.t1);
        if (t1 < winStart || t0 > winEnd) continue;
        const f = midiToFreq(n.midi + (STATE.settings.transpose||0), STATE.settings.a4); addOsc(f, tToWhen(t0), tToWhen(t1), volAcc);
      }
    }
  }
  function tickToSecRaw(tick){ let usPerQN = 500000; let lastTick=0; let acc=0; for (const te of STATE.tempos){ if (te.time<=tick){ acc += (te.time-lastTick) * usPerQN / (STATE.ppq*1e6); lastTick = te.time; usPerQN = te.microsecPerQN; } } acc += (tick-lastTick) * usPerQN / (STATE.ppq*1e6); return acc / (STATE.settings.tempoMul||1); }
}
function scheduleMetronome(winStart, winEnd){
  const qnSec0 = (STATE.tempos[0]?.microsecPerQN || 500000)/1e6 / (STATE.settings.tempoMul||1);
  const add = (when,beat)=>{ const o = audio.ctx.createOscillator(); o.type="triangle"; o.frequency.value=beat%4===0? 2200:1600; const g = audio.ctx.createGain(); g.gain.setValueAtTime(0.0, when); g.gain.linearRampToValueAtTime(0.15, when+0.005); g.gain.exponentialRampToValueAtTime(0.0001, when+0.08); o.connect(g).connect(audio.comp); o.start(when); o.stop(when+0.1); audio.oscPool.push(o); };
  let beat=0;
  for (let sec=Math.floor(winStart/qnSec0)*qnSec0; sec<=winEnd; sec+=qnSec0){ if (sec>=winStart && sec<=winEnd) add(audio.ctx.currentTime + (sec - getNowPos()), beat); beat++; }
}
function micro2sec(us){ return us/1e6; }

let pitchBuf = new Float32Array(2048); let lastPitchHz = 0, lastMidi = null, lastCentErr=0, octFixed=false;
function analyzePitch(){
  const an = audio.mic.analyser; if(!an) return null;
  const n = an.fftSize; if (pitchBuf.length<n) pitchBuf = new Float32Array(n);
  an.getFloatTimeDomainData(pitchBuf);
  const rms = Math.hypot(...pitchBuf)/Math.sqrt(n);
  const db = 20*Math.log10(rms||1e-9);
  UI.mRms.textContent=rms.toFixed(3); UI.mDb.textContent=db.toFixed(1);
  if (db < STATE.settings.gateDb) return null;
  const hz = mpm(pitchBuf, audio.ctx.sampleRate); if (!hz) return null;
  let midi = freqToMidi(hz, STATE.settings.a4); let guideMidi = getGuideMidiAt(getNowPos());
  octFixed=false; if (STATE.settings.octLock && guideMidi!=null){ const base=guideMidi; while (midi - base > 6) { midi -= 12; octFixed=true; } while (base - midi > 6) { midi += 12; octFixed=true; } }
  const centErr = midiToCentsErr(midi, guideMidi); lastPitchHz = hz; lastMidi = midi; lastCentErr = centErr;
  UI.mPitch.textContent=hz.toFixed(2); UI.mMidi.textContent=(midi??-1).toFixed(2); UI.mCent.textContent=isFinite(centErr)? centErr.toFixed(1):"-"; UI.mOct.textContent=octFixed? "Y":"N";
  return {hz, midi, centErr, db};
}
function mpm(buf, sr){
  const N = buf.length;
  let maxTau = Math.floor(sr/50), minTau = Math.floor(sr/1000);
  if (maxTau>=N) maxTau=N-1;
  const nsdf = new Float32Array(maxTau); let maxPos=0, maxVal=0;
  let acf0=0; for (let i=0;i<N;i++) acf0 += buf[i]*buf[i];
  for (let tau=minTau; tau<maxTau; tau++){
    let acf=0, msc=0;
    for (let i=0;i<N-tau;i++){ const a=buf[i], b=buf[i+tau]; acf += a*b; msc += a*a + b*b; }
    const v = 2*acf/msc; nsdf[tau]=v; if (v>maxVal){ maxVal=v; maxPos=tau; }
  }
  if (maxVal<0.6) return null;
  const tau = maxPos; const y1=nsdf[tau-1], y2=nsdf[tau], y3=nsdf[tau+1]; const better = tau + 0.5*(y1 - y3)/(y1 - 2*y2 + y3);
  return sr / better;
}
let smoothQ = [];
function scoringStep(){
  const tol = STATE.settings.tolCents||20;
  const pt = analyzePitch(); const Hz = STATE.settings.analysisHz||20; UI.mHz.textContent = Hz.toFixed(0);
  if (!pt){ updateRtGauge(); return; }
  const now = getNowPos(); const guide = getGuideMidiAt(now); if (guide==null){ updateRtGauge(); return; }
  const winMs = STATE.settings.vibratoMs||70; smoothQ.push(pt.centErr);
  while (smoothQ.length > Math.max(3, Math.floor(winMs/ (1000/Hz)))) smoothQ.shift();
  const sm = median(smoothQ);
  STATE.score.frames++; const abs = Math.abs(sm); if (abs <= tol) STATE.score.inTol++; if (abs >= 50) STATE.score.bigOut++; STATE.score.meanAbs += abs; STATE.score.diffAcc.push(abs);
  UI.rtGauge.value = Math.min(100, Math.round(100*STATE.score.inTol/STATE.score.frames)); UI.rtGaugeVal.textContent = `${Math.round(100*STATE.score.inTol/STATE.score.frames)||0} 点`;
}
function finalizeScore(){
  if (STATE.score.frames===0){ UI.finalReport.textContent=""; return; }
  const base = 100*STATE.score.inTol/STATE.score.frames;
  const meanAbs = STATE.score.meanAbs/STATE.score.frames;
  const stability = 100 - Math.min(100, (stddev(STATE.score.diffAcc)||0));
  const centerBonus = Math.max(0, 10 - Math.min(10, meanAbs/2));
  const stabBonus = Math.max(0, Math.min(10, stability/10));
  const penalty = Math.min(20, 100*STATE.score.bigOut/STATE.score.frames);
  const total = Math.max(0, Math.min(100, base + centerBonus + stabBonus - penalty));
  STATE.score.final = {total: +total.toFixed(1), base:+base.toFixed(1), center:+centerBonus.toFixed(1), stability:+stabBonus.toFixed(1), penalty:+penalty.toFixed(1), meanAbs:+meanAbs.toFixed(1), maxOut:+(Math.max(...STATE.score.diffAcc)||0).toFixed(1), frames:STATE.score.frames};
  UI.finalReport.innerHTML = `<div><b>総合点：</b>${STATE.score.final.total} 点</div><div>基本点：${STATE.score.final.base} / センタリング +${STATE.score.final.center} / 安定度 +${STATE.score.final.stability} / 減点 -${STATE.score.final.penalty}</div><div>合致率：${Math.round(STATE.score.inTol/STATE.score.frames*100)}% / 平均誤差：${STATE.score.final.meanAbs} c / 最大外れ：${STATE.score.final.maxOut} c</div>`;
  saveSong(); STATE.score.frames=0; STATE.score.inTol=0; STATE.score.bigOut=0; STATE.score.meanAbs=0; STATE.score.diffAcc=[]; smoothQ=[];
}
function updateRtGauge(){ UI.rtGauge.value = Math.round(100*STATE.score.inTol/Math.max(1,STATE.score.frames)); UI.rtGaugeVal.textContent=`${UI.rtGauge.value} 点`; }
function stddev(a){ if(!a.length) return 0; const m=a.reduce((s,x)=>s+x,0)/a.length; const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/a.length; return Math.sqrt(v); }
function median(a){ const b=[...a].sort((x,y)=>x-y); const m=b.length>>1; return b.length%2? b[m] : 0.5*(b[m-1]+b[m]); }
function getGuideMidiAt(sec){ const tl = STATE.timeline; if (!tl.length) return null; let lo=0, hi=tl.length-1, mid=0; while (lo<=hi){ mid = (lo+hi)>>1; const n = tl[mid]; if (sec < n.t0) hi = mid-1; else if (sec > n.t1) lo = mid+1; else return n.midi; } return null; }
function midiToFreq(midi, a4=442){ return a4 * Math.pow(2, (midi-69)/12); }
function freqToMidi(freq, a4=442){ return 69 + 12*Math.log2(freq/a4); }
function midiToCentsErr(mPlayed, mGuide){ if (mGuide==null||mPlayed==null) return NaN; return (mPlayed - mGuide)*100; }
function setupCanvases(){ const dpr = window.devicePixelRatio||1; const wP = Math.min(160, Math.round(window.innerWidth*0.2)); const piano=document.getElementById("piano"); const chart=document.getElementById("chart"); piano.width = wP*dpr; piano.height = 420*dpr; piano.style.width=wP+"px"; piano.style.height="420px"; chart.width = Math.min(1400, Math.round(window.innerWidth - wP - 80))*dpr; chart.height = 420*dpr; chart.style.height = "420px"; CANVAS.piano = piano; CANVAS.chart=chart; CANVAS.ctxP = piano.getContext("2d"); CANVAS.ctxC = chart.getContext("2d"); CANVAS.dpi=dpr; }
function draw(){ drawPiano(); drawChart(); }
function drawPiano(){ const ctx = CANVAS.ctxP, W=CANVAS.piano.width, H=CANVAS.piano.height, dpr=CANVAS.dpi; ctx.clearRect(0,0,W,H); const oct = STATE.settings.zoomOct||3; const keys = oct*12; const yScale = H / (oct*12); ctx.fillStyle="#11141c"; ctx.fillRect(0,0,W,H); for (let i=0;i<=keys;i++){ const y = Math.round(i*yScale); if (i%12===0){ ctx.fillStyle="#172133"; ctx.fillRect(0,y,W,Math.max(2*dpr,2)); } if (i%12===11){ ctx.fillStyle="#24324e"; ctx.fillRect(0,Math.round((i+1)*yScale)-2,W,4); } } const midi = (STATE.settings.kbdHL==="mic")? lastMidi : getGuideMidiAt(getNowPos()); if (midi!=null){ const y = midiToY(midi); ctx.fillStyle="#264e63"; ctx.fillRect(0,y-6*dpr,W,12*dpr); } }
function drawChart(){ const ctx = CANVAS.ctxC, W=CANVAS.chart.width, H=CANVAS.chart.height, dpr=CANVAS.dpi; ctx.clearRect(0,0,W,H); ctx.save(); ctx.fillStyle="#0c1018"; ctx.fillRect(0,0,W,H); const playX = Math.floor(W*0.33); ctx.strokeStyle="#2a2f3a"; ctx.lineWidth=1*dpr; for (let i=0;i<10;i++){ ctx.beginPath(); ctx.moveTo(0,i*H/10); ctx.lineTo(W,i*H/10); ctx.stroke(); } ctx.strokeStyle="#5ac8fa"; ctx.lineWidth=2*dpr; ctx.beginPath(); ctx.moveTo(playX,0); ctx.lineTo(playX,H); ctx.stroke();
  const tol = STATE.settings.tolCents||20; const px = Math.max(2, STATE.settings.guidePx||6)*dpr; ctx.lineWidth = px;
  for (const n of STATE.timeline){ const x0 = timeToX(n.t0), x1 = timeToX(n.t1); const y = midiToY(n.midi); const dy = centsToY(tol); ctx.fillStyle = "rgba(90,200,250,0.12)"; ctx.fillRect(x0, y-dy, x1-x0, dy*2); ctx.strokeStyle = "#9fdcff"; ctx.beginPath(); ctx.moveTo(x0, y); ctx.lineTo(x1-1, y); ctx.stroke(); }
  if (lastMidi!=null){ const y = midiToY(lastMidi); const x = playX+6*dpr; ctx.strokeStyle = (Math.abs(lastCentErr)<=tol)? "#2ecc71" : "#ff6b6b"; ctx.lineWidth = 3*dpr; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+60*dpr, y); ctx.stroke(); }
  drawVertLabels(ctx); ctx.restore();
  function timeToX(t){ const pos = getNowPos(); const dt = t - pos; const s = W*0.67; return Math.floor(W*0.33 + dt/ (totalDur()||1) * s); }
}
function midiToY(midi){ const oct = STATE.settings.zoomOct||3; const H = CANVAS.chart.height; const centerMidi = 60 + (STATE.settings.yOffset||0); const span = (oct*12); const min = centerMidi - span/2; const max = centerMidi + span/2; const clamped = Math.max(min, Math.min(max, midi)); return Math.round((max - clamped) / span * H); }
function centsToY(c){ return Math.abs(c) * (CANVAS.chart.height / ((STATE.settings.zoomOct||3)*12*100)); }
function drawVertLabels(ctx){ ctx.save(); const scale = STATE.settings.labelScale||1; ctx.fillStyle="#e6eaf2"; ctx.font = `${Math.round(12*scale)}px system-ui, sans-serif`; const lines = 12*(STATE.settings.zoomOct||3); for (let i=0;i<=lines;i+=2){ const midi = 60 + (STATE.settings.yOffset||0) + (lines/2 - i); const y = midiToY(midi); const n = midiToName(midi, STATE.settings.noteLabel||"JPN"); ctx.fillText(n, 6, y+4); } ctx.restore(); }
function midiToName(m, mode){ const namesCDE = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]; const namesJP  = ["ド","ド#","レ","レ#","ミ","ファ","ファ#","ソ","ソ#","ラ","ラ#","シ"]; const names = (mode==="CDE")? namesCDE : namesJP; const n = names[(Math.round(m)%12+12)%12]; const o = Math.floor(m/12)-1; return `${n}${o}`; }
let lastAnim=0, fpsCount=0, fpsLast=performance.now();
function tick(ts){ requestAnimationFrame(tick); if (!lastAnim) lastAnim=ts||0; const dt = (ts-lastAnim)/1000; lastAnim=ts||0; scheduleFrame(); const Hz = STATE.settings.analysisHz||20; if (!tick._acc) tick._acc=0; tick._acc += dt; if (tick._acc >= 1/Hz){ tick._acc = 0; scoringStep(); } draw(); fpsCount++; const now = performance.now(); if (now - fpsLast > 500){ CANVAS.fps = Math.round(fpsCount * 1000 / (now - fpsLast)); fpsCount=0; fpsLast=now; document.getElementById("mFps").textContent=CANVAS.fps; } document.getElementById("mCtxTime").textContent = audio.ctx? audio.ctx.currentTime.toFixed(3):"-"; document.getElementById("mLook").textContent = audio.sched.lookahead.toFixed(2); }
# ======= ここまで app.js 実装 =======